---
title: Java并发笔记3
date: 2018-07-09 14:15:15
tags: [Java,编程语言,读书笔记, Java并发编程实战]
categories: [编程语言]
---
### Java并发编程实战第二章 线程安全
编写线程安全代码的核心是管理对状态的访问，尤其*共享*和*可变*状态的访问。通过**同步**协调对对象可变状态的访问可以实现一个对象的线程安全。同步最基本的机制是`synchronized`关键词，但是同步(synchronization)这个属于还包括:`volatile`变量、显式(explicit)锁和原子(atomic)变量。

#### 最佳实践
1. 在设计时就考虑线程安全
2. 利用封装(encapsulation)，不可变性(immutablility)，清晰指定不可变量(invariants)是比较好的实践。

### 2.1 什么是线程安全
1. 所有线程安全合理定义的核心都是*正确性*。*正确性* 意味着类符合其规范，一个良好的规范定义了约束对象状态的*不变量*和描述操作结果的*后置条件*。
>线程安全的定义: 如果一个类在多个线程访问时正确运行，则它是*线程安全*的，不管运行时环境如何调度或者交错这些线程的执行，并且在调用代码部分没有多余的同步和协调。
2. 线程安全类会封装任何需要的同步，从而使客户不必在自己实现。
3. 无状态(`stateless`)的类永远是线程安全的

### 2.2 原子性
#### 2.2.1 `Race Condition`
> 一个*竞争条件*会在计算正确性依赖于运行时中多线程相对时间或者交错出现。换句话说，正确答案取决于幸运时机。大部分的竞争条件的类型为`check-then-act`型，此时可能会有陈旧观察用于决定下一步做什么。

例子：
1. 自增操作是一个`read-modify-write`操作，分三步完成而非一步，所以是非原子操作。
2. 星巴克约会的例子
3. `lazy initialization`的例子

#### 原子操作
> 如果从一个执行A复合操作的线程的角度来看，执行B复合操作的线程要么将B所有操作执行完，要么完全不执行B系列的任何操作，那么，A和B是对彼此来说是原子的。一个*原子操作*是指与包括自己在内的所有在同一状态上的操作集都是互为原子操作的操作集。

#### 原子变量
在`java.util.concurrent.atomic`包下有很多原子变量，可以执行原子操作。如`AtomicLong`的实例方法`incrementAndGet()`。对于无状态的类添加一个线程安全的属性，则这个类仍然是线程安全的，但是如果添加的多余一个，则不保证这个类依然是线程安全的类。
>在实践中，要尽量使用线程安全对象来管理类的状态。

### 2.3 加锁
#### Intrisic Lock(固有锁)
`synchronized`是Java内置固有锁，即可以修饰方法，又可以修饰代码块。修饰方法时默认由方法所属对象作为`intrisic locks`或者`monitor locks`
